<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Serverless LAPS Azure Function and Proactive Remediation | markkerry.github.io</title>
<meta name=keywords content="Azure,Azure Function,PowerShell,Key Vault,Serverless,Proactive Remediations">
<meta name=description content="Based on the great solution created by John Seerden with a little help creating and deploying Azure Functions by the Serverless on Azure YouTube channel.
All of the code in this post can be found in my GitHub repo
I am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.
What is Serverless LAPS Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines.">
<meta name=author content="Mark kerry">
<link rel=canonical href=https://markkerry.github.io/posts/serverless-laps-azure-function/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.b9ff4cc257e914dab489bd18086151800e18f91456a5174bf28489210227a659.css integrity="sha256-uf9MwlfpFNq0ib0YCGFRgA4Y+RRWpRdL8oSJIQInplk=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://markkerry.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://markkerry.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://markkerry.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://markkerry.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://markkerry.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','')</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XZDLE8M8RG"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-XZDLE8M8RG',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Serverless LAPS Azure Function and Proactive Remediation">
<meta property="og:description" content="Based on the great solution created by John Seerden with a little help creating and deploying Azure Functions by the Serverless on Azure YouTube channel.
All of the code in this post can be found in my GitHub repo
I am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.
What is Serverless LAPS Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://markkerry.github.io/posts/serverless-laps-azure-function/">
<meta property="og:image" content="https://markkerry.github.io/images/cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-04-25T11:04:45+01:00">
<meta property="article:modified_time" content="2021-04-25T11:04:45+01:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://markkerry.github.io/images/cover.png">
<meta name=twitter:title content="Serverless LAPS Azure Function and Proactive Remediation">
<meta name=twitter:description content="Based on the great solution created by John Seerden with a little help creating and deploying Azure Functions by the Serverless on Azure YouTube channel.
All of the code in this post can be found in my GitHub repo
I am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.
What is Serverless LAPS Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://markkerry.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Serverless LAPS Azure Function and Proactive Remediation","item":"https://markkerry.github.io/posts/serverless-laps-azure-function/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Serverless LAPS Azure Function and Proactive Remediation","name":"Serverless LAPS Azure Function and Proactive Remediation","description":"Based on the great solution created by John Seerden with a little help creating and deploying Azure Functions by the Serverless on Azure YouTube channel.\nAll of the code in this post can be found in my GitHub repo\nI am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.\nWhat is Serverless LAPS Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines.","keywords":["Azure","Azure Function","PowerShell","Key Vault","Serverless","Proactive Remediations"],"articleBody":"Based on the great solution created by John Seerden with a little help creating and deploying Azure Functions by the Serverless on Azure YouTube channel.\nAll of the code in this post can be found in my GitHub repo\nI am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.\nWhat is Serverless LAPS Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines. But it requires an agent, GPO and a connection to AD either on-premises or via a VPN. This doesn’t cover remote, AAD joined devices managed by Intune.\nServerless LAPS is an Azure Function (PowerShell) which will generate a unique password, add it to Azure Key Vault, and then set the password on the local machine.\nFor more info, check out John Seerden’s blog post.\nWhat are Proactive Remediations Proactive Remediations is a part of Endpoint Analytics, which is a part of Microsoft Productivity Score. Accessible via the MEM portal, Proactive Remediations can be seen as a similar solution to ConfigMgr’s Configuration Items/Baselines. They are a set of custom PowerShell scripts to detect if the machine meets the desired state and if non-compliant, run the remediation script. Once the remediation script completes, the detection script runs again to confirm if the machine is now compliant with the desired state.\nThis feels like the perfect solution to automatically run Serverless LAPS on internet managed devices. The detection will check the age of the password of the specified local admin account and run the remediation if the account doesn’t exist or if the password age is greater than 180 days.\nSolution Overview The following diagram illustrates the high-level overview of the Azure resources and the process flow.\n The machine will start by running the MEM Proactive Remediation. If the Detection script determines the local admin password on the device is older than 180 days, it will return non-compliant and the Remediation script will run. The remediation script is invoked on the client. The machine will send an HTTP POST method containing it’s hostname to the Azure Function (all over HTTPS) The Azure Function generates a unique, secure password and sends it along with the hostname to an Azure Key Vault, which it has access to via it’s Managed Identity. The Access Policy for the Key Vault has the Managed Identity defined with Set permission for Secrets. The function sends an HTTP Response (over HTTPS) back to the device containing the new password. The password is then reset and the Intune Management Extension log is overwritten to hide the Function URI. The Proactive Remediation is then marked as compliant after the Detection script is run again and determined that the password has been reset 0 days ago.  Prerequisites To complete the steps in this post you will need the following:\n Azure Functions Core Tools Azure CLI .Net Core SDK An Azure subscription  Windows Installation - Chocolatey choco install azure-functions-core-tools-3 -y choco install azure-cli -y choco install dotnetcore-sdk -y macOS Installation - Homebrew brew update brew tap azure/functions brew install azure-functions-core-tools@3 brew install azure-cli brew install --cask dotnet-sdk Create the SLAPS Azure Function Locally Using Azure Function Core Tools Start by creating the folder structure on your machine\ncd C:\\git\\repos mkdir Serverless-LAPS cd Serverless-LAPS mkdir function cd function mkdir src mkdir tst cd src Next we can create (initialise) a new project. Ensure the function name is unique (do not use “mk”).\nfunc init fn-slaps-mk --powershell Now change directory into the new project.\n NOTE: Ensure you change “mk” to your initials or whatever you want. The function name should be unique as will be included in the URI to trigger it.\n cd fn-slaps-mk And create a new function called Set-KVSecret with an HTTP Trigger and authorisation level of “function”.\nfunc new --name Set-KVSecret --template \"HTTP Trigger\" --authlevel \"function\" Then select PowerShell as the language. This appears twice, just highlight the first one and hit return.\nThe src directory will then look as follows\n├───src │ └───fn-slaps-mk │ ├───.vscode │ └───Set-KVSecret └───tst Test the Local Function Now, I want to test the local function. Using modified code of what the final function will look like, open src\\fn-slaps-mk\\Set-KVSecret\\run.ps1 file, delete the existing code and paste the code found below.\n Note: Here we are just generating a random password and returning the password in the response. There is no Key Vault interaction here.\n using namespace System.Net param( [Parameter(Mandatory = $true)] $Request ) # Write to the Azure Functions log stream. Write-Host \"PowerShell HTTP trigger function processed a request.\" # Function to generate a random password function New-Password { $alphabets = 'a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,t,u,v,w,x,y,z' $numbers = 2..9 $specialCharacters = '@,#,$,%,\u0026,*,?,+' $array = @() $array += $alphabets.Split(',') | Get-Random -Count 8 $array[0] = $array[0].ToUpper() $array[-1] = $array[-1].ToUpper() $array += $numbers | Get-Random -Count 5 $array += $specialCharacters.Split(',') | Get-Random -Count 2 ($array | Get-Random -Count $array.Count) -join \"\" } # Generate a random password $password = New-Password # Return the password in the response Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{ Body = $password }) Save and close run.ps1 then in your terminal start the function\nfunc start Notice the function is available via http://localhost:7071/api/Set-KVSecret\nThen invoke the function with the following code\n$userName = \"Administrator\" # Azure Function Request Body $body = @\" { \"keyName\": \"$env:COMPUTERNAME\", \"contentType\": \"Local Administrator Credentials\", \"tags\": { \"Username\": \"$userName\" } } \"@ # URI of the local function $uri = \"http://localhost:7071/api/Set-KVSecret\" # Trigger Azure Function. try { Invoke-RestMethod -Uri $uri -Method POST -Body $body -ContentType 'application/json' -ErrorAction Stop } catch { Write-Host \"$(Get-Date -format g): Failed to submit Local Administrator configuration. StatusCode: $($_.Exception.Response.StatusCode.value__). StatusDescription: $($_.Exception.Response.StatusDescription)\" } Every time you run the code above the local function will return a different, unique password. For example:\nq6dMc\u0026g2j4kX?39 h9w3JC*k4pi76u@ 58\u00266tn74uYeaJ$p 2mdx#fN63t4a@H7 Update the Function Code OK now that that works, let’s update the src\\fn-slaps-mk\\Set-KVSecret\\run.ps1 code with the code which will run in the Azure Function once it is deployed.\n Note: Later you will have to enter the Key Vault name in $keyVaultName variable\n using namespace System.Net param( [Parameter(Mandatory = $true)] $Request ) # Write to the Azure Functions log stream. Write-Host \"PowerShell HTTP trigger function processed a request.\" # Function to generate a random password function New-Password { $alphabets = 'a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,t,u,v,w,x,y,z' $numbers = 2..9 $specialCharacters = '@,#,$,%,\u0026,*,?,+' $array = @() $array += $alphabets.Split(',') | Get-Random -Count 8 $array[0] = $array[0].ToUpper() $array[-1] = $array[-1].ToUpper() $array += $numbers | Get-Random -Count 5 $array += $specialCharacters.Split(',') | Get-Random -Count 2 ($array | Get-Random -Count $array.Count) -join \"\" } # Enter the name of your Key Vault below $keyVaultName = \"\" # Azure Key Vault resource to obtain access token $vaultTokenUri = 'https://vault.azure.net' $apiVersion = '2017-09-01' # Get Azure Key Vault Access Token using the Function's Managed Service Identity try { $authToken = Invoke-RestMethod -Method Get -Headers @{ 'Secret' = $env:MSI_SECRET } -Uri \"$($env:MSI_ENDPOINT)?resource=$vaultTokenUri\u0026api-version=$apiVersion\" } catch { Write-Host \"ERROR, could not HTTP GET Azure Key Vault Access Token using the Function's Managed Service Identity $_\" } # Use Azure Key Vault Access Token to create Authentication Header $authHeader = @{ Authorization = \"Bearer $($authToken.access_token)\" } # Generate a random password $password = New-Password # Generate a new body to set a secret in the Azure Key Vault $body = $request.body | Select-Object -Property * -ExcludeProperty keyName # Append the random password to the new body $body | Add-Member -NotePropertyName value -NotePropertyValue \"$password\" # Convert the body to JSON $body = $body | ConvertTo-Json # Azure Key Vault Uri to set a secret $vaultSecretUri = \"https://$keyVaultName.vault.azure.net/secrets/$($request.Body.keyName)/?api-version=2016-10-01\" # Set the secret in Azure Key Vault try { $null = Invoke-RestMethod -Method PUT -Body $body -Uri $vaultSecretUri -ContentType 'application/json' -Headers $authHeader -ErrorAction Stop $pwdValue = $password } catch { Write-Host \"ERROR, could not HTTP PUT to the Azure KeyVault $_\" $pwdValue = $null } # Return the password in the response Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{ Body = $pwdValue }) Create the Azure Resources Using Azure CLI The following can be completed using AZ CLI installed locally on your machine or Azure Cloud Shell. If using your local install of AZ CLI, first log into your Azure account\naz login Change the variables below to suit your resource group name, location, storage account name, function name and Key Vault name.\nrgName=\"rg-serverless-laps\" location=\"westeurope\" saName=\"saslaps4857392\" funcName=\"fn-slaps-mk\" kvName=\"kv-slaps-mk\" # create the resource group az group create --name $rgName --location $location # check storage account name is available first az storage account check-name --name $saName # create the storage account az storage account create --name $saName \\  --resource-group $rgName \\  --location $location \\  --sku Standard_LRS \\  --kind Storagev2 \\  --access-tier Hot # create the function app az functionapp create --name $funcName \\  --resource-group $rgName \\  --consumption-plan-location $location \\  --storage-account $saName \\  --assign-identity [system] \\  --runtime powershell \\  --os-type Windows \\  --functions-version 3 # list the function app az functionapp list --out table # create Key Vault az keyvault create --name $kvName \\  --resource-group $rgName \\  --location $location # get the function app managed identity spID=$(az resource list -n $funcName --query [*].identity.principalId --out tsv) # assign managed identity to the key vault access policy az keyvault set-policy --name $kvName \\  --secret-permissions create \\  --spn $spID Update and Deploy the Local Function to Azure Hopefully you have already updated the code in run.ps1 with the code that will run within the Azure Function once it is deployed? If not see above.\nNow it’s time to deploy the local function the Azure Function resource we have just created. From the src\\fn-slaps-mk directory:\n$funcName=\"fn-slaps-mk\" func azure functionapp publish $funcName Test the Azure Function And that’s it, the function should now be deployed and running in Azure. To test the function, use the Reset-LocalAdminPasswordRemediate.ps1 file in my GitHub Repo.\nJust ensure you change the $userNameand $uri variables to the local admin account and function URI, respectively.\nMEM Proactive Remediation Getting started with Proactive Remediations can be found in the following Microsoft documentation.\nThe detection and remediation scripts can be found in my GitHub repo. But let’s start by breaking down the two scripts.\nDetection The detection script quite simply checks the following:\n Does the specified local admin exist? If not return non-compliant so the remediation script creates it and sets the password. If the local admin does exist, check when the password was last set. If less than 180 days, return compliant and exit. If greater than 180 days return non-compliant and run remediation to reset the password.  # Enter the name of the local admin account below $userName = \"\" $user = Get-LocalUser -Name $userName -ErrorAction SilentlyContinue $date = (Get-Date).AddDays(-180) # Validate compliance if ($null -ne $user) { # account was found if ($user.PasswordLastSet -gt $date) { # Password was set less than 180 days ago Write-Output \"Compliant. Password last set $($user.PasswordLastSet)\" exit 0 } else { # Password was set more than 180 days ago Write-Output \"Non-compliant. Password last set $($user.PasswordLastSet)\" exit 1 } } else { # account was not found Write-Output \"Non-compliant. Account not found\" exit 1 } Remediation The Remediation script is around 150 lines which is a little too much to add to the this post, which I am already aware has too much code in it already. As stated above you can find the the Remediation code in the Reset-LocalAdminPasswordRemediate.ps1 file in my GitHub Repo. Just ensure you change the $userNameand $uri variables to the local admin account and function URI, respectively.\n","wordCount":"1909","inLanguage":"en","image":"https://markkerry.github.io/images/cover.png","datePublished":"2021-04-25T11:04:45+01:00","dateModified":"2021-04-25T11:04:45+01:00","author":{"@type":"Person","name":"Mark kerry"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://markkerry.github.io/posts/serverless-laps-azure-function/"},"publisher":{"@type":"Organization","name":"markkerry.github.io","logo":{"@type":"ImageObject","url":"https://markkerry.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://markkerry.github.io/ accesskey=h title="markkerry.github.io (Alt + H)">markkerry.github.io</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://markkerry.github.io/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://markkerry.github.io/archive title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://markkerry.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://markkerry.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://markkerry.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Serverless LAPS Azure Function and Proactive Remediation
</h1>
<div class=post-meta>April 25, 2021&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Mark kerry
</div>
</header>
<figure class=entry-cover>
<img loading=lazy srcset="https://markkerry.github.io/posts/serverless-laps-azure-function/images/cover_hu121f4f4a3965575e5f6eedf353b8a073_27651_360x0_resize_box_3.png 360w ,https://markkerry.github.io/posts/serverless-laps-azure-function/images/cover_hu121f4f4a3965575e5f6eedf353b8a073_27651_480x0_resize_box_3.png 480w ,https://markkerry.github.io/posts/serverless-laps-azure-function/images/cover.png 667w" sizes="(min-width: 768px) 720px, 100vw" src=https://markkerry.github.io/posts/serverless-laps-azure-function/images/cover.png alt width=667 height=206>
<p>Recycle your local admin password with Azure Functions, Key Vault and Proactive Remediations</p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#what-is-serverless-laps aria-label="What is Serverless LAPS">What is Serverless LAPS</a></li>
<li>
<a href=#what-are-proactive-remediations aria-label="What are Proactive Remediations">What are Proactive Remediations</a></li>
<li>
<a href=#solution-overview aria-label="Solution Overview">Solution Overview</a></li>
<li>
<a href=#prerequisites aria-label=Prerequisites>Prerequisites</a><ul>
<li>
<a href=#windows-installation---chocolatey aria-label="Windows Installation - Chocolatey">Windows Installation - Chocolatey</a></li>
<li>
<a href=#macos-installation---homebrew aria-label="macOS Installation - Homebrew">macOS Installation - Homebrew</a></li></ul>
</li>
<li>
<a href=#create-the-slaps-azure-function-locally-using-azure-function-core-tools aria-label="Create the SLAPS Azure Function Locally Using Azure Function Core Tools">Create the SLAPS Azure Function Locally Using Azure Function Core Tools</a></li>
<li>
<a href=#test-the-local-function aria-label="Test the Local Function">Test the Local Function</a><ul>
<li>
<a href=#update-the-function-code aria-label="Update the Function Code">Update the Function Code</a></li></ul>
</li>
<li>
<a href=#create-the-azure-resources-using-azure-cli aria-label="Create the Azure Resources Using Azure CLI">Create the Azure Resources Using Azure CLI</a></li>
<li>
<a href=#update-and-deploy-the-local-function-to-azure aria-label="Update and Deploy the Local Function to Azure">Update and Deploy the Local Function to Azure</a></li>
<li>
<a href=#test-the-azure-function aria-label="Test the Azure Function">Test the Azure Function</a></li>
<li>
<a href=#mem-proactive-remediation aria-label="MEM Proactive Remediation">MEM Proactive Remediation</a><ul>
<li>
<a href=#detection aria-label=Detection>Detection</a></li>
<li>
<a href=#remediation aria-label=Remediation>Remediation</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Based on the great solution created by <a href=https://www.srdn.io/2018/09/serverless-laps-powered-by-microsoft-intune-azure-functions-and-azure-key-vault/>John Seerden</a> with a little help creating and deploying Azure Functions by the <a href=https://www.youtube.com/channel/UCmoWqg6T-c8zEGm4sZdnwbA>Serverless on Azure</a> YouTube channel.</p>
<p>All of the code in this post can be found in my <a href=https://github.com/markkerry/Serverless-LAPS>GitHub repo</a></p>
<p>I am only posting a few differences here, such as creating the Azure resources using AZ CLI and creating/testing/deploying the function using the Azure Functions Core Tools CLI.</p>
<h2 id=what-is-serverless-laps>What is Serverless LAPS<a hidden class=anchor aria-hidden=true href=#what-is-serverless-laps>#</a></h2>
<p>Local Admin Password Solution (LAPS) is a great solution from Microsoft to allow IT admins to automatically recycle local admin accounts on domain joined Windows machines. But it requires an agent, GPO and a connection to AD either on-premises or via a VPN. This doesn&rsquo;t cover remote, AAD joined devices managed by Intune.</p>
<p>Serverless LAPS is an Azure Function (PowerShell) which will generate a unique password, add it to Azure Key Vault, and then set the password on the local machine.</p>
<p>For more info, check out <a href=https://www.srdn.io/2018/09/serverless-laps-powered-by-microsoft-intune-azure-functions-and-azure-key-vault/>John Seerden&rsquo;s blog post.</a></p>
<h2 id=what-are-proactive-remediations>What are Proactive Remediations<a hidden class=anchor aria-hidden=true href=#what-are-proactive-remediations>#</a></h2>
<p>Proactive Remediations is a part of Endpoint Analytics, which is a part of Microsoft Productivity Score. Accessible via the MEM portal, Proactive Remediations can be seen as a similar solution to ConfigMgr&rsquo;s Configuration Items/Baselines. They are a set of custom PowerShell scripts to detect if the machine meets the desired state and if non-compliant, run the remediation script. Once the remediation script completes, the detection script runs again to confirm if the machine is now compliant with the desired state.</p>
<p>This feels like the perfect solution to automatically run Serverless LAPS on internet managed devices. The detection will check the age of the password of the specified local admin account and run the remediation if the account doesn&rsquo;t exist or if the password age is greater than 180 days.</p>
<h2 id=solution-overview>Solution Overview<a hidden class=anchor aria-hidden=true href=#solution-overview>#</a></h2>
<p>The following diagram illustrates the high-level overview of the Azure resources and the process flow.</p>
<p><img loading=lazy src=images/slaps.png alt=SLAPS>
</p>
<ol>
<li>The machine will start by running the MEM Proactive Remediation. If the Detection script determines the local admin password on the device is older than 180 days, it will return non-compliant and the Remediation script will run.</li>
<li>The remediation script is invoked on the client.</li>
<li>The machine will send an HTTP POST method containing it&rsquo;s hostname to the Azure Function (all over HTTPS)</li>
<li>The Azure Function generates a unique, secure password and sends it along with the hostname to an Azure Key Vault, which it has access to via it&rsquo;s Managed Identity. The Access Policy for the Key Vault has the Managed Identity defined with <strong>Set</strong> permission for <strong>Secrets</strong>.</li>
<li>The function sends an HTTP Response (over HTTPS) back to the device containing the new password.</li>
<li>The password is then reset and the Intune Management Extension log is overwritten to hide the Function URI.</li>
<li>The Proactive Remediation is then marked as compliant after the Detection script is run again and determined that the password has been reset 0 days ago.</li>
</ol>
<h2 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h2>
<p>To complete the steps in this post you will need the following:</p>
<ul>
<li><a href=https://github.com/Azure/azure-functions-core-tools>Azure Functions Core Tools</a></li>
<li><a href=https://docs.microsoft.com/en-gb/cli/azure/install-azure-cli>Azure CLI</a></li>
<li><a href=https://docs.microsoft.com/en-us/dotnet/core/install/>.Net Core SDK</a></li>
<li>An Azure subscription</li>
</ul>
<h3 id=windows-installation---chocolatey>Windows Installation - Chocolatey<a hidden class=anchor aria-hidden=true href=#windows-installation---chocolatey>#</a></h3>
<pre tabindex=0><code class=language-terminal data-lang=terminal>choco install azure-functions-core-tools-3 -y
choco install azure-cli -y
choco install dotnetcore-sdk -y
</code></pre><h3 id=macos-installation---homebrew>macOS Installation - Homebrew<a hidden class=anchor aria-hidden=true href=#macos-installation---homebrew>#</a></h3>
<pre tabindex=0><code class=language-terminal data-lang=terminal>brew update
brew tap azure/functions
brew install azure-functions-core-tools@3
brew install azure-cli
brew install --cask dotnet-sdk
</code></pre>
<h2 id=create-the-slaps-azure-function-locally-using-azure-function-core-tools>Create the SLAPS Azure Function Locally Using Azure Function Core Tools<a hidden class=anchor aria-hidden=true href=#create-the-slaps-azure-function-locally-using-azure-function-core-tools>#</a></h2>
<p>Start by creating the folder structure on your machine</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>cd C:\git\repos
mkdir Serverless-LAPS
cd Serverless-LAPS
mkdir function
cd function
mkdir src
mkdir tst
cd src
</code></pre><p>Next we can create (initialise) a new project. Ensure the function name is unique (do not use &ldquo;mk&rdquo;).</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>func init fn-slaps-mk --powershell
</code></pre><p><img loading=lazy src=images/initFunction.png alt=initFunction>
</p>
<p>Now change directory into the new project.</p>
<blockquote>
<p><strong>NOTE</strong>: Ensure you change &ldquo;mk&rdquo; to your initials or whatever you want. The function name should be unique as will be included in the URI to trigger it.</p>
</blockquote>
<pre tabindex=0><code class=language-terminal data-lang=terminal>cd fn-slaps-mk
</code></pre><p>And create a new function called <strong>Set-KVSecret</strong> with an HTTP Trigger and authorisation level of &ldquo;function&rdquo;.</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>func new --name Set-KVSecret --template &quot;HTTP Trigger&quot; --authlevel &quot;function&quot;
</code></pre><p>Then select PowerShell as the language. This appears twice, just highlight the first one and hit return.</p>
<p><img loading=lazy src=images/newFunction.png alt=newFunction>
</p>
<p>The <code>src</code> directory will then look as follows</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>├───src
│   └───fn-slaps-mk
│       ├───.vscode
│       └───Set-KVSecret
└───tst
</code></pre><h2 id=test-the-local-function>Test the Local Function<a hidden class=anchor aria-hidden=true href=#test-the-local-function>#</a></h2>
<p>Now, I want to test the local function. Using modified code of what the final function will look like, open <code>src\fn-slaps-mk\Set-KVSecret\run.ps1</code> file, delete the existing code and paste the code found below.</p>
<blockquote>
<p><strong>Note:</strong> Here we are just generating a random password and returning the password in the response. There is no Key Vault interaction here.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>using namespace System.Net

<span style=color:#66d9ef>param</span>(
    [<span style=color:#66d9ef>Parameter</span>(<span style=color:#66d9ef>Mandatory</span> = $true)]
    $Request
)

<span style=color:#75715e># Write to the Azure Functions log stream.</span>
Write-Host <span style=color:#e6db74>&#34;PowerShell HTTP trigger function processed a request.&#34;</span>

<span style=color:#75715e># Function to generate a random password</span>
<span style=color:#66d9ef>function</span> New-Password {
    $alphabets = <span style=color:#e6db74>&#39;a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,t,u,v,w,x,y,z&#39;</span>
    $numbers = 2..9
    $specialCharacters = <span style=color:#e6db74>&#39;@,#,$,%,&amp;,*,?,+&#39;</span>
    $array = @()
    $array += $alphabets.Split(<span style=color:#e6db74>&#39;,&#39;</span>) | Get-Random -Count 8
    $array[0] = $array[0].ToUpper()
    $array[-1] = $array[-1].ToUpper()
    $array += $numbers | Get-Random -Count 5
    $array += $specialCharacters.Split(<span style=color:#e6db74>&#39;,&#39;</span>) | Get-Random -Count 2
    ($array | Get-Random -Count $array.Count) -join <span style=color:#e6db74>&#34;&#34;</span>
}

<span style=color:#75715e># Generate a random password</span>
$password = New-Password

<span style=color:#75715e># Return the password in the response</span>
Push-OutputBinding -Name Response -Value (<span style=color:#66d9ef>[HttpResponseContext]</span>@{
    Body = $password
})
</code></pre></div><p>Save and close <code>run.ps1</code> then in your terminal start the function</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>func start
</code></pre><p>Notice the function is available via <code>http://localhost:7071/api/Set-KVSecret</code></p>
<p>Then invoke the function with the following code</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$userName = <span style=color:#e6db74>&#34;Administrator&#34;</span>

<span style=color:#75715e># Azure Function Request Body</span>
$body = <span style=color:#e6db74>@&#34;
</span><span style=color:#e6db74>{
</span><span style=color:#e6db74>    &#34;keyName&#34;: &#34;$env:COMPUTERNAME&#34;,
</span><span style=color:#e6db74>    &#34;contentType&#34;: &#34;Local Administrator Credentials&#34;,
</span><span style=color:#e6db74>    &#34;tags&#34;: {
</span><span style=color:#e6db74>        &#34;Username&#34;: &#34;$userName&#34;
</span><span style=color:#e6db74>    }
</span><span style=color:#e6db74>}
</span><span style=color:#e6db74>&#34;@</span>

<span style=color:#75715e># URI of the local function</span>
$uri = <span style=color:#e6db74>&#34;http://localhost:7071/api/Set-KVSecret&#34;</span>

<span style=color:#75715e># Trigger Azure Function.</span>
<span style=color:#66d9ef>try</span> {
    Invoke-RestMethod -Uri $uri -Method POST -Body $body -ContentType <span style=color:#e6db74>&#39;application/json&#39;</span> -ErrorAction Stop
}
<span style=color:#66d9ef>catch</span> {
    Write-Host <span style=color:#e6db74>&#34;</span>$(Get-Date -format g)<span style=color:#e6db74>: Failed to submit Local Administrator configuration. StatusCode: </span>$($_.Exception.Response.StatusCode.value__)<span style=color:#e6db74>. StatusDescription: </span>$($_.Exception.Response.StatusDescription)<span style=color:#e6db74>&#34;</span>
}
</code></pre></div><p>Every time you run the code above the local function will return a different, unique password. For example:</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>q6dMc&amp;g2j4kX?39
h9w3JC*k4pi76u@
58&amp;6tn74uYeaJ$p
2mdx#fN63t4a@H7
</code></pre><h3 id=update-the-function-code>Update the Function Code<a hidden class=anchor aria-hidden=true href=#update-the-function-code>#</a></h3>
<p>OK now that that works, let&rsquo;s update the <code>src\fn-slaps-mk\Set-KVSecret\run.ps1</code> code with the code which will run in the Azure Function once it is deployed.</p>
<blockquote>
<p><strong>Note:</strong> Later you will have to enter the Key Vault name in <code>$keyVaultName</code> variable</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>using namespace System.Net

<span style=color:#66d9ef>param</span>(
    [<span style=color:#66d9ef>Parameter</span>(<span style=color:#66d9ef>Mandatory</span> = $true)]
    $Request
)

<span style=color:#75715e># Write to the Azure Functions log stream.</span>
Write-Host <span style=color:#e6db74>&#34;PowerShell HTTP trigger function processed a request.&#34;</span>

<span style=color:#75715e># Function to generate a random password</span>
<span style=color:#66d9ef>function</span> New-Password {
    $alphabets = <span style=color:#e6db74>&#39;a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,t,u,v,w,x,y,z&#39;</span>
    $numbers = 2..9
    $specialCharacters = <span style=color:#e6db74>&#39;@,#,$,%,&amp;,*,?,+&#39;</span>
    $array = @()
    $array += $alphabets.Split(<span style=color:#e6db74>&#39;,&#39;</span>) | Get-Random -Count 8
    $array[0] = $array[0].ToUpper()
    $array[-1] = $array[-1].ToUpper()
    $array += $numbers | Get-Random -Count 5
    $array += $specialCharacters.Split(<span style=color:#e6db74>&#39;,&#39;</span>) | Get-Random -Count 2
    ($array | Get-Random -Count $array.Count) -join <span style=color:#e6db74>&#34;&#34;</span>
}

<span style=color:#75715e># Enter the name of your Key Vault below</span>
$keyVaultName = <span style=color:#e6db74>&#34;&#34;</span>

<span style=color:#75715e># Azure Key Vault resource to obtain access token</span>
$vaultTokenUri = <span style=color:#e6db74>&#39;https://vault.azure.net&#39;</span>
$apiVersion = <span style=color:#e6db74>&#39;2017-09-01&#39;</span>

<span style=color:#75715e># Get Azure Key Vault Access Token using the Function&#39;s Managed Service Identity</span>
<span style=color:#66d9ef>try</span> {
    $authToken = Invoke-RestMethod -Method Get -Headers @{ <span style=color:#e6db74>&#39;Secret&#39;</span> = $env:MSI_SECRET } -Uri <span style=color:#e6db74>&#34;</span>$($env:MSI_ENDPOINT)<span style=color:#e6db74>?resource=$vaultTokenUri&amp;api-version=$apiVersion&#34;</span>
}
<span style=color:#66d9ef>catch</span> {
    Write-Host <span style=color:#e6db74>&#34;ERROR, could not HTTP GET Azure Key Vault Access Token using the Function&#39;s Managed Service Identity $_&#34;</span>
}
<span style=color:#75715e># Use Azure Key Vault Access Token to create Authentication Header</span>
$authHeader = @{ Authorization = <span style=color:#e6db74>&#34;Bearer </span>$($authToken.access_token)<span style=color:#e6db74>&#34;</span> }

<span style=color:#75715e># Generate a random password</span>
$password = New-Password

<span style=color:#75715e># Generate a new body to set a secret in the Azure Key Vault</span>
$body = $request.body | Select-Object -Property * -ExcludeProperty keyName

<span style=color:#75715e># Append the random password to the new body</span>
$body | Add-Member -NotePropertyName value -NotePropertyValue <span style=color:#e6db74>&#34;$password&#34;</span>

<span style=color:#75715e># Convert the body to JSON</span>
$body = $body | ConvertTo-Json

<span style=color:#75715e># Azure Key Vault Uri to set a secret</span>
$vaultSecretUri = <span style=color:#e6db74>&#34;https://$keyVaultName.vault.azure.net/secrets/</span>$($request.Body.keyName)<span style=color:#e6db74>/?api-version=2016-10-01&#34;</span>

<span style=color:#75715e># Set the secret in Azure Key Vault</span>
<span style=color:#66d9ef>try</span> {
    $null = Invoke-RestMethod -Method PUT -Body $body -Uri $vaultSecretUri -ContentType <span style=color:#e6db74>&#39;application/json&#39;</span> -Headers $authHeader -ErrorAction Stop
    $pwdValue = $password 
}
<span style=color:#66d9ef>catch</span> {
    Write-Host <span style=color:#e6db74>&#34;ERROR, could not HTTP PUT to the Azure KeyVault $_&#34;</span>
    $pwdValue = $null
}

<span style=color:#75715e># Return the password in the response</span>
Push-OutputBinding -Name Response -Value (<span style=color:#66d9ef>[HttpResponseContext]</span>@{
    Body = $pwdValue
})
</code></pre></div>
<h2 id=create-the-azure-resources-using-azure-cli>Create the Azure Resources Using Azure CLI<a hidden class=anchor aria-hidden=true href=#create-the-azure-resources-using-azure-cli>#</a></h2>
<p>The following can be completed using AZ CLI installed locally on your machine or Azure Cloud Shell. If using your local install of AZ CLI, first log into your Azure account</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>az login
</code></pre></div><p>Change the variables below to suit your resource group name, location, storage account name, function name and Key Vault name.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>rgName<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;rg-serverless-laps&#34;</span>
location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;westeurope&#34;</span>
saName<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;saslaps4857392&#34;</span>
funcName<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;fn-slaps-mk&#34;</span>
kvName<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;kv-slaps-mk&#34;</span>

<span style=color:#75715e># create the resource group</span>
az group create --name $rgName --location $location

<span style=color:#75715e># check storage account name is available first</span>
az storage account check-name --name $saName

<span style=color:#75715e># create the storage account</span>
az storage account create --name $saName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --resource-group $rgName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --location $location <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --sku Standard_LRS <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --kind Storagev2 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --access-tier Hot

<span style=color:#75715e># create the function app</span>
az functionapp create --name $funcName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --resource-group $rgName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --consumption-plan-location $location <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --storage-account $saName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --assign-identity <span style=color:#f92672>[</span>system<span style=color:#f92672>]</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --runtime powershell <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --os-type Windows <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --functions-version <span style=color:#ae81ff>3</span>

<span style=color:#75715e># list the function app</span>
az functionapp list --out table

<span style=color:#75715e># create Key Vault</span>
az keyvault create --name $kvName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --resource-group $rgName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --location $location

<span style=color:#75715e># get the function app managed identity</span>
spID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>az resource list -n $funcName --query <span style=color:#f92672>[</span>*<span style=color:#f92672>]</span>.identity.principalId --out tsv<span style=color:#66d9ef>)</span>

<span style=color:#75715e># assign managed identity to the key vault access policy</span>
az keyvault set-policy --name $kvName <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --secret-permissions create <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --spn $spID
</code></pre></div>
<h2 id=update-and-deploy-the-local-function-to-azure>Update and Deploy the Local Function to Azure<a hidden class=anchor aria-hidden=true href=#update-and-deploy-the-local-function-to-azure>#</a></h2>
<p>Hopefully you have already updated the code in <code>run.ps1</code> with the code that will run within the Azure Function once it is deployed? If not see <a href=https://markkerry.github.io/posts/serverless-laps-azure-function/#update-the-function-code>above.</a></p>
<p>Now it&rsquo;s time to deploy the local function the Azure Function resource we have just created. From the <code>src\fn-slaps-mk</code> directory:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$funcName<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;fn-slaps-mk&#34;</span>

func azure functionapp publish $funcName
</code></pre></div>
<h2 id=test-the-azure-function>Test the Azure Function<a hidden class=anchor aria-hidden=true href=#test-the-azure-function>#</a></h2>
<p>And that&rsquo;s it, the function should now be deployed and running in Azure. To test the function, use the <code>Reset-LocalAdminPasswordRemediate.ps1</code> file in my <a href=https://github.com/markkerry/Serverless-LAPS/blob/main/proactive-remediation/Reset-LocalAdminPasswordRemediate.ps1>GitHub Repo</a>.</p>
<p>Just ensure you change the <code>$userName</code>and <code>$uri</code> variables to the local admin account and function URI, respectively.</p>
<h2 id=mem-proactive-remediation>MEM Proactive Remediation<a hidden class=anchor aria-hidden=true href=#mem-proactive-remediation>#</a></h2>
<p>Getting started with Proactive Remediations can be found in the following <a href=https://docs.microsoft.com/en-us/mem/analytics/proactive-remediations>Microsoft documentation</a>.</p>
<p>The detection and remediation scripts can be found in my GitHub repo. But let&rsquo;s start by breaking down the two scripts.</p>
<h3 id=detection>Detection<a hidden class=anchor aria-hidden=true href=#detection>#</a></h3>
<p>The detection script quite simply checks the following:</p>
<ul>
<li>Does the specified local admin exist? If not return non-compliant so the remediation script creates it and sets the password.</li>
<li>If the local admin does exist, check when the password was last set. If less than 180 days, return compliant and exit. If greater than 180 days return non-compliant and run remediation to reset the password.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#75715e># Enter the name of the local admin account below</span>
$userName = <span style=color:#e6db74>&#34;&#34;</span>
$user = Get-LocalUser -Name $userName -ErrorAction SilentlyContinue
$date = (Get-Date).AddDays(-180)

<span style=color:#75715e># Validate compliance</span>
<span style=color:#66d9ef>if</span> ($null <span style=color:#f92672>-ne</span> $user) {
    <span style=color:#75715e># account was found</span>
    <span style=color:#66d9ef>if</span> ($user.PasswordLastSet <span style=color:#f92672>-gt</span> $date) {
        <span style=color:#75715e># Password was set less than 180 days ago</span>
        Write-Output <span style=color:#e6db74>&#34;Compliant. Password last set </span>$($user.PasswordLastSet)<span style=color:#e6db74>&#34;</span>
        exit 0
    }
    <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e># Password was set more than 180 days ago</span>
        Write-Output <span style=color:#e6db74>&#34;Non-compliant. Password last set </span>$($user.PasswordLastSet)<span style=color:#e6db74>&#34;</span>
        exit 1
    }
}
<span style=color:#66d9ef>else</span> {
    <span style=color:#75715e># account was not found</span>
    Write-Output <span style=color:#e6db74>&#34;Non-compliant. Account not found&#34;</span>
    exit 1
}
</code></pre></div>
<h3 id=remediation>Remediation<a hidden class=anchor aria-hidden=true href=#remediation>#</a></h3>
<p>The Remediation script is around 150 lines which is a little too much to add to the this post, which I am already aware has too much code in it already. As stated above you can find the the Remediation code in the <code>Reset-LocalAdminPasswordRemediate.ps1</code> file in my <a href=https://github.com/markkerry/Serverless-LAPS/blob/main/proactive-remediation/Reset-LocalAdminPasswordRemediate.ps1>GitHub Repo</a>. Just ensure you change the <code>$userName</code>and <code>$uri</code> variables to the local admin account and function URI, respectively.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://markkerry.github.io/tags/azure/>Azure</a></li>
<li><a href=https://markkerry.github.io/tags/azure-function/>Azure Function</a></li>
<li><a href=https://markkerry.github.io/tags/powershell/>PowerShell</a></li>
<li><a href=https://markkerry.github.io/tags/key-vault/>Key Vault</a></li>
<li><a href=https://markkerry.github.io/tags/serverless/>Serverless</a></li>
<li><a href=https://markkerry.github.io/tags/proactive-remediations/>Proactive Remediations</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://markkerry.github.io/posts/centos8-setup/>
<span class=title>« Prev Page</span>
<br>
<span>Installing & Configuring CentOS 8 Minimal Install</span>
</a>
<a class=next href=https://markkerry.github.io/posts/hugo-and-github-pages-part1/>
<span class=title>Next Page »</span>
<br>
<span>HUGO Static Site Hosted on GitHub Pages - Part 1: Intro</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://markkerry.github.io/>markkerry.github.io</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>