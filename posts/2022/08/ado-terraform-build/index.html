<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Terraform in Azure DevOps Pipelines | markkerry.github.io</title><meta name=keywords content="Terraform,Azure DevOps,Azure,Git"><meta name=description content="The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.
It&rsquo;s setup with the master or main branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a terraform plan and terraform validate."><meta name=author content="Mark kerry"><link rel=canonical href=https://markkerry.github.io/posts/2022/08/ado-terraform-build/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b9ff4cc257e914dab489bd18086151800e18f91456a5174bf28489210227a659.css integrity="sha256-uf9MwlfpFNq0ib0YCGFRgA4Y+RRWpRdL8oSJIQInplk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://markkerry.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://markkerry.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://markkerry.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://markkerry.github.io/apple-touch-icon.png><link rel=mask-icon href=https://markkerry.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-XZDLE8M8RG"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XZDLE8M8RG",{anonymize_ip:!1})}</script><meta property="og:title" content="Terraform in Azure DevOps Pipelines"><meta property="og:description" content="The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.
It&rsquo;s setup with the master or main branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a terraform plan and terraform validate."><meta property="og:type" content="article"><meta property="og:url" content="https://markkerry.github.io/posts/2022/08/ado-terraform-build/"><meta property="og:image" content="https://markkerry.github.io/media/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-14T09:53:20+01:00"><meta property="article:modified_time" content="2022-08-14T09:53:20+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://markkerry.github.io/media/cover.png"><meta name=twitter:title content="Terraform in Azure DevOps Pipelines"><meta name=twitter:description content="The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.
It&rsquo;s setup with the master or main branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a terraform plan and terraform validate."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://markkerry.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Terraform in Azure DevOps Pipelines","item":"https://markkerry.github.io/posts/2022/08/ado-terraform-build/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Terraform in Azure DevOps Pipelines","name":"Terraform in Azure DevOps Pipelines","description":"The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.\nIt\u0026rsquo;s setup with the master or main branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a terraform plan and terraform validate.","keywords":["Terraform","Azure DevOps","Azure","Git"],"articleBody":"The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.\nIt’s setup with the master or main branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a terraform plan and terraform validate. After the pull request is approved a build pipeline will run which initiates a terraform plan to a plan file, which is then archived as an artifact. If all checks are passed the release will need to be approved, which then starts a release pipeline. This performs a terraform apply using the plan file artifact, to deploy the resources into Azure. Once all is deployed the final step is to switch back to the master/main branch in VS code, pull the merged code and delete the old branch.\nFor a detailed video walkthrough, follow Terraform And Azure DevOps - How To Configure by Jack Tracey. I found this really helpful when setting up for myself.\nRequirements Visual Studio Code Git Azure Subscription - Sign up for free credits Azure DevOps Organisation - Get one for free Request free parallelism - If using the free plan You now have to make a request for free parallelism if using private repos on the free plan as stated on Microsoft Docs:\nNote We have temporarily disabled the free grant of parallel jobs for public projects and for certain private projects in new organizations. However, you can request this grant by submitting a request. Existing organizations and projects are not affected. Please note that it takes us 2-3 business days to respond to your free tier requests.\nAll code from the this post can be found on GitHub\nSetup DevOps Project I started by creating a free DevOps organisation and then creating a new private project called devops-terraform-build. Create a .gitignore file using the Terraform template which will basically tell it to not upload state and tfvars files. This created a repo under Repos which I cloned into VS Code.\nEnsure you select a local directory and that you cd into the directory using your terminal, which has Git installed.\nAzure Resources A few things need to be in place in Azure in order for Azure DevOps and Terraform to be able to interact with it. Manually create the following in Azure to host your Terraform backend, SPN and secrets:\nA Resource group for the following resources: Storage account and container for remote state Key Vault An App registration, copying the relevant secret, application id, tenant id. Assign the app registration Owner permissions on the subscription Assign an access policy for the app registration of list and get, Secret Permissions in Key Vault Open Key Vault and create the following new secrets:\nName Value stgAccountName-key-1 The Storage Account’s Access Key1 stgAccountName-key-2 The Storage Account’s Access Key2 SPN-Application-client-ID The App Registration’s Client ID SPN-Object-ID The App Registration’s Object ID SPN-Secret The App Registrations’s Secret value SPN-Tenant-ID The tenant ID of the SPN Configure Project Create a Service Connection in DevOps project to allow access to the Azure Subscription.\nSelect Project Settings \u003e Pipelines / Service Connections \u003e New Service Connection\nSelect Azure Resource Manager \u003e Next \u003e Service principal (manual) \u003e Next\nConfigure it with the following:\nName Value Environment Azure Cloud Scope Level Subscription Subscription Id The Azure Subscription ID Subscription Name The Azure Subsciption Name Service Principle Id The app registration’s Application (client) ID Credential Service principal key Service principal key The app registration’s Secret value Tenant ID The Azure Tenant ID Service Connection name I named mine the same as the app registration Click Verify\nNext, to create an Azure DevOps Variable Group, select Pipelines \u003e Library \u003e + Variable group\nName it the same as the Azure Key Vault which has been created. Select Link secrets from an Azure key vault as variables. Then select the Azure Subscription spn and the Key vault it has access to. Then finally add all of the secrets in the key vault.\nCreate the Plan CI Pipline We’ll start by creating the CI/Build pipeline, but this isn’t the first pipeline to be initiated in the process. It’s easier to create this one first and then clone it later.\nClick Pipelines \u003e Create Pipeline \u003e Use the classic editor. Name it terraform-plan\nSelect Azure Repos Git as the source and then ensure it has selected the project, Repo and branch. Click Continue\nClick Start with an Empty Job. Rename the pipeline and select the “Agent Specification” as Ubuntu 20.04\nSelect Agent job 1 and rename it to the same name as the Pipeline. Then click the + to add a task. Search Terraform tool installer, and click Get it free. Install it, and select your organisation when prompted. Once installed enter the Version on the task as 1.2.6 (This was the latest version for linux at the time of writing).\nAdd a new Command Line task and name it terraform init. Set the script as:\nterraform init -backend-config=\"access_key=$(Name of access key variable)\" This will tell it to check the variable group to match the stgAccountName-key-1 variable, which is a Storage Account’s access key.\nClone the task and this time rename to terraform validate. Set the script the same:\nterraform validate Clone it again and this time rename it to terraform plan and set the script as:\nterraform plan -input=false -out=tfplan -var=\"spn-client-id=$(CHANGEME-spn-client-id)\" -var=\"spn-client-secret=$(CHANGEME-spn-secret)\" -var=\"spn-tenant-id=$(CHANGEME-spn-tenant-id)\" This will tell it not to prompt for any input variables at runtime and out to a tfplan file. Ensure the variables are updated with the name of your variables.\nNow create a new task to create an archive of the plan file. The task to add is called Archive Files and configure as follows:\nName Value Disaplay name archive terraform plan files Root folder or file to archive terraform Archive type tar Tar compression gz Archive file to create $(Build.ArtifactStagingDirectory)/$(Build.BuildId)-tfplan.tgz And finally it is time to publish the pipeline artifacts. Add a task called Publish Pipline Artifacts and configure as follows:\nName Value Display name publish terraform plan artifact File or directory path $(Build.ArtifactStagingDirectory)/$(Build.BuildId)-tfplan.tgz Artifact name $(Build.BuildId)-tfplan Artifact publish location Azure pipeline The pipeline tasks should look as follows:\nThat’s the last “task” to add for this pipeline. Now at the top of the pipeline, click Variables \u003e Variable groups \u003e Link variable group. Then select the variable groups which was created earlier.\nFinally, click Triggers \u003e tick enable continuous integration \u003e Add the path terraform/ so that it only takes affect on git changes within the terraform directory (yet to create locally).\nClick save when complete to save the pipeline.\nCreate the Status Check \u0026 Plan, Pull Request Pipline We now need to create a new piplline, not for CI but for to validate the code after Pull Requests are created. Start by cloning the terraform-plan pipeline and make the following changes:\nRename it to terraform-status-check-plan-and-validate Delete the last two tasks archive terraform plan files and publish terraform plan artifact Click the terraform plan task and delete the -out=tfplan from the Script. Click Triggers and un-tick (disable) Enable continuous integration Save the pipeline Release Pipeline The CD/release pipeline is the final one to configure to deploy the resources in Azure using Terraform.\nGo to Pipelines \u003e Releases \u003e New pipeline \u003e name it terraform apply \u003e select Empty job.\nName Stage 1 as terraform apply. Then click Add artifact and select from the terraform-build pipeline which was created earlier.\nThen enable CD by clicking the lightening icon, then Enabled under Continuous deployment trigger.\nConfigure the job, under Stages, click 1 job, 0 task. Enter the following:\nName Value Display name terraform apply Agent pool Azure Pipelines Agent Specification ubuntu-20.04 Click the + to add a task. Search for and select Extract files. Change Archive file patterns to:\n$(System.ArtifactsDirectory)/_terraform-plan/$(Build.BuildId)-tfplan/$(Build.BuildId)-tfplan.tgz Set the Destination folder to:\n$(System.DefaultWorkingDirectory)/ Add a new task called Terraform tool installer, set 1.2.6 as the version.\nAdd a new task called Command line, name it terraform init and use the same command line as in the build task.\nterraform init -backend-config=\"access_key=$(Name of access key variable)\" Then Advanced \u003e Working directory set it to:\n$(System.DefaultWorkingDirectory)/terraform Clone the Command line task and create a new one called terraform apply. Script is:\nterraform apply -auto-approve -input=false tfplan All tasks will then looks as follows:\nNow link our variable groups. Click Variables \u003e Variable groups \u003e Link varibale group \u003e Select the variable group created earlier.\nThat’s all that is required to configure the pipeline tasks, but we need to add a Pre-deployment condition, go back to Pipeline and click the following:\nEnable Pre-deployment approvals, I set myself as the approver as I am the only person in my DevOps organisation. I also changed the timeout to 7 Days.\nThe release pipeline should now look as follows:\nClick Save\nBranch Policies The Branch policy will ensure that code is only being commited via a pull request and not directly in the main/master branch.\nClick Repos \u003e Branches \u003e under your default branch, hover over it with mouse and in the far right, click the three dots \u003e More options \u003e Branch Policies. Set as follows:\nScroll down and enable Squash merge\nBuild validation \u003e + (add). We only want the terraform-status-check-plan-and-validate pipeline to run if there have been any commits on *.tf files. Set as follows:\nAnd finally add myself under Automatically included reviewers\nAnd that’s it for the DevOps configuration. Now it is time to write some Terraform configurations and commit the code to test the pipelines.\nTesting the Build and Release Pipelines To create a new branch in VS Code, click Source Control \u003e three dots \u003e Branch \u003e Create Branch \u003e name it test\nI should not be allowed to commit code changes directly to the master branch now there is a “branch policy” in place. Start by creating a folder called terraform and add the following .tf. files.\ndevops-terraform-build │ │ .gitignore │ README.md │ └───terraform backend.tf providers.tf resource_group.tf variables.tf The .gitignore will look something like this:\n# Local .terraform directories **/.terraform/* # .tfstate files *.tfstate *.tfstate.* # .tfvars files *.tfvars The backend.tf file. Ensure you set the correct name for the resource group and storage account which will host the state file.\nterraform { backend \"azurerm\" { resource_group_name = \"NAME OF RG\" storage_account_name = \"NAME OF STG\" container_name = \"devops-tf-state\" key = \"terraform.tfstate\" } } The providers.tf file. Ensure you set your unique subscription id.\nterraform { required_providers { azurerm = { source = \"hashicorp/azurerm\" version = \"=3.0.0\" } } } provider \"azurerm\" { subscription_id = \"SUBSCRIPTION ID\" client_id = var.spn-client-id client_secret = var.spn-client-secret tenant_id = var.spn-tenant-id features {} } The resource_group.tf file. Set the name of the resource group you want to create. This is all that will be created for now.\nresource \"azurerm_resource_group\" \"rg1\" { name = \"devops-terraform-rg1\" location = \"UK South\" } The variables.tf file.\nvariable \"spn-client-id\" {} variable \"spn-client-secret\" {} variable \"spn-tenant-id\" {} Deploy Resources Now we can deploy the resource group. In VS Code, click Source Control \u003e then the + (stage) \u003e Tick to commit \u003e Name the commit \u003e and then Push\nBack in Azure DevOps, in Repos you’ll see the test branch has been commited and that you have an option to Create a pull request. Click it.\nFill in name and description and click Create\nNotice the pipeline which performs a terraform plan and validate has passed\nClick it to see the jobs.\nSelect the terraform plan job to see detailed output. Notice one resource will be created; the resource group.\nIf I open Azure and browse to the Storage Account and Container, I can see the state file created by the terraform init command.\nNow approve the Pull request to merge the test branch into Master\nThis will initiate the build pipeline to create a plan file as an artifact.\nSelect archive terraform plan files for detailed output of the command.\nNow approve the release by going to Pipelines \u003e Releases\nThen watch the release pipepline progress and deploy the Resource Group to Azure.\nOnce complete you can see the new Resource Group “devops-terraform-rg1” was created.\nThat’s a lot of work to deploy a resource group. But now I can create new branches with more resources and have Azure DevOps deploy then when the branch is merged. But first I will show you how to cleanup up the old branch in VS Code.\nClean up local repo Now the “test” branch has been merged into main/master (in my example; master), we can cleanup the local test branch and swtich back to master.\ngit checkout master You’ll notice in VS Code in the bottom left that the branch has changed.\nFetch and prune. The -p option tells fetch to delete any references that no longer exist on the remote origin. Git remote prune will also remove deleted branches.\ngit fetch -p Then “pull” the updates on the origin repo to your local repo.\ngit pull Delete the old, local “test” branch\ngit branch -D test Verify your local branches\ngit branch -a That’s it. Create a new branch if you want to commit new code as a pull request.\n","wordCount":"2228","inLanguage":"en","image":"https://markkerry.github.io/media/cover.png","datePublished":"2022-08-14T09:53:20+01:00","dateModified":"2022-08-14T09:53:20+01:00","author":{"@type":"Person","name":"Mark kerry"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://markkerry.github.io/posts/2022/08/ado-terraform-build/"},"publisher":{"@type":"Organization","name":"markkerry.github.io","logo":{"@type":"ImageObject","url":"https://markkerry.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://markkerry.github.io/ accesskey=h title="markkerry.github.io (Alt + H)">markkerry.github.io</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://markkerry.github.io/about/ title=About><span>About</span></a></li><li><a href=https://markkerry.github.io/archive title=Archive><span>Archive</span></a></li><li><a href=https://markkerry.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://markkerry.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://markkerry.github.io/posts/>Posts</a></div><h1 class=post-title>Terraform in Azure DevOps Pipelines</h1><div class=post-meta>August 14, 2022&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Mark kerry</div></header><figure class=entry-cover><img loading=lazy srcset="https://markkerry.github.io/posts/2022/08/ado-terraform-build/media/cover_hufed55eaa0f9a501928ea93339bf65825_35013_360x0_resize_box_3.png 360w ,https://markkerry.github.io/posts/2022/08/ado-terraform-build/media/cover_hufed55eaa0f9a501928ea93339bf65825_35013_480x0_resize_box_3.png 480w ,https://markkerry.github.io/posts/2022/08/ado-terraform-build/media/cover.png 667w" sizes="(min-width: 768px) 720px, 100vw" src=https://markkerry.github.io/posts/2022/08/ado-terraform-build/media/cover.png alt width=667 height=389><p>Deploy Azure resources using Terraform in Azure DevOps pipelines</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#requirements aria-label=Requirements>Requirements</a></li><li><a href=#setup-devops-project aria-label="Setup DevOps Project">Setup DevOps Project</a></li><li><a href=#azure-resources aria-label="Azure Resources">Azure Resources</a></li><li><a href=#configure-project aria-label="Configure Project">Configure Project</a></li><li><a href=#create-the-plan-ci-pipline aria-label="Create the Plan CI Pipline">Create the Plan CI Pipline</a></li><li><a href=#create-the-status-check--plan-pull-request-pipline aria-label="Create the Status Check &amp;amp; Plan, Pull Request Pipline">Create the Status Check & Plan, Pull Request Pipline</a></li><li><a href=#release-pipeline aria-label="Release Pipeline">Release Pipeline</a></li><li><a href=#branch-policies aria-label="Branch Policies">Branch Policies</a></li><li><a href=#testing-the-build-and-release-pipelines aria-label="Testing the Build and Release Pipelines">Testing the Build and Release Pipelines</a></li><li><a href=#deploy-resources aria-label="Deploy Resources">Deploy Resources</a></li><li><a href=#clean-up-local-repo aria-label="Clean up local repo">Clean up local repo</a></li></ul></div></details></div><div class=post-content><p>The following will walkthrough deploying Azure resources using Terraform in Azure DevOps Pipelines. Although its a detailed guide, there is an expectation that the person following already has a good understanding of Git, Azure and Terraform.</p><p>It&rsquo;s setup with the <code>master</code> or <code>main</code> branch created in DevOps and then cloned locally. A new branch is created and then committed to DevOps (Branch policies will restrict committing directly into master/main). A Pull Request is then created and the first pipeline is run which initialites a <code>terraform plan</code> and <code>terraform validate</code>. After the pull request is approved a build pipeline will run which initiates a <code>terraform plan</code> to a plan file, which is then archived as an artifact. If all checks are passed the release will need to be approved, which then starts a release pipeline. This performs a <code>terraform apply</code> using the plan file artifact, to deploy the resources into Azure. Once all is deployed the final step is to switch back to the master/main branch in VS code, pull the merged code and delete the old branch.</p><p>For a detailed video walkthrough, follow <a href="https://www.youtube.com/watch?v=AWXOYS-SBfY">Terraform And Azure DevOps - How To Configure</a> by Jack Tracey. I found this really helpful when setting up for myself.</p><h2 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h2><ul><li>Visual Studio Code</li><li>Git</li><li>Azure Subscription - Sign up for free credits</li><li>Azure DevOps Organisation - Get one for free<ul><li><a href=https://aka.ms/azpipelines-parallelism-request>Request free parallelism</a> - If using the free plan</li></ul></li></ul><p>You now have to make a request for free parallelism if using private repos on the free plan as stated on Microsoft Docs:</p><blockquote><p><strong>Note</strong> <em>We have temporarily disabled the free grant of parallel jobs for public projects and for certain private projects in new organizations. However, you can request this grant by submitting <a href=https://aka.ms/azpipelines-parallelism-request>a request</a>. Existing organizations and projects are not affected. Please note that it takes us 2-3 business days to respond to your free tier requests.</em></p></blockquote><p>All code from the this post can be found on <a href=https://github.com/markkerry/terraform-in-azure-devops-pipelines>GitHub</a></p><h2 id=setup-devops-project>Setup DevOps Project<a hidden class=anchor aria-hidden=true href=#setup-devops-project>#</a></h2><p>I started by creating a free DevOps organisation and then creating a new private project called <strong>devops-terraform-build</strong>. Create a <code>.gitignore</code> file using the Terraform template which will basically tell it to not upload state and tfvars files. This created a repo under <strong>Repos</strong> which I cloned into VS Code.</p><p><img loading=lazy src=media/cloneRepo.png alt=cloneRepo></p><p>Ensure you select a local directory and that you <code>cd</code> into the directory using your terminal, which has Git installed.</p><h2 id=azure-resources>Azure Resources<a hidden class=anchor aria-hidden=true href=#azure-resources>#</a></h2><p>A few things need to be in place in Azure in order for Azure DevOps and Terraform to be able to interact with it. Manually create the following in Azure to host your Terraform backend, SPN and secrets:</p><ul><li>A Resource group for the following resources:<ul><li>Storage account and container for remote state</li><li>Key Vault</li></ul></li><li>An App registration, copying the relevant secret, application id, tenant id.<ul><li>Assign the app registration <strong>Owner</strong> permissions on the subscription</li><li>Assign an access policy for the app registration of <strong>list</strong> and <strong>get</strong>, Secret Permissions in Key Vault</li></ul></li></ul><p>Open Key Vault and create the following new secrets:</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>stgAccountName-key-1</td><td>The Storage Account&rsquo;s Access Key1</td></tr><tr><td>stgAccountName-key-2</td><td>The Storage Account&rsquo;s Access Key2</td></tr><tr><td>SPN-Application-client-ID</td><td>The App Registration&rsquo;s Client ID</td></tr><tr><td>SPN-Object-ID</td><td>The App Registration&rsquo;s Object ID</td></tr><tr><td>SPN-Secret</td><td>The App Registrations&rsquo;s Secret value</td></tr><tr><td>SPN-Tenant-ID</td><td>The tenant ID of the SPN</td></tr></tbody></table><h2 id=configure-project>Configure Project<a hidden class=anchor aria-hidden=true href=#configure-project>#</a></h2><p>Create a Service Connection in DevOps project to allow access to the Azure Subscription.</p><p>Select <strong>Project Settings</strong> > <strong>Pipelines</strong> / <strong>Service Connections</strong> > <strong>New Service Connection</strong></p><p>Select <strong>Azure Resource Manager</strong> > <strong>Next</strong> > <strong>Service principal (manual)</strong> > <strong>Next</strong></p><p>Configure it with the following:</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>Environment</td><td>Azure Cloud</td></tr><tr><td>Scope Level</td><td>Subscription</td></tr><tr><td>Subscription Id</td><td>The Azure Subscription ID</td></tr><tr><td>Subscription Name</td><td>The Azure Subsciption Name</td></tr><tr><td>Service Principle Id</td><td>The app registration&rsquo;s Application (client) ID</td></tr><tr><td>Credential</td><td>Service principal key</td></tr><tr><td>Service principal key</td><td>The app registration&rsquo;s Secret value</td></tr><tr><td>Tenant ID</td><td>The Azure Tenant ID</td></tr><tr><td>Service Connection name</td><td>I named mine the same as the app registration</td></tr></tbody></table><p>Click <strong>Verify</strong></p><p>Next, to create an Azure DevOps Variable Group, select <strong>Pipelines</strong> > <strong>Library</strong> > <strong>+ Variable group</strong></p><p>Name it the same as the Azure Key Vault which has been created. Select <strong>Link secrets from an Azure key vault as variables</strong>. Then select the Azure Subscription spn and the Key vault it has access to. Then finally add all of the secrets in the key vault.</p><h2 id=create-the-plan-ci-pipline>Create the Plan CI Pipline<a hidden class=anchor aria-hidden=true href=#create-the-plan-ci-pipline>#</a></h2><p>We&rsquo;ll start by creating the CI/Build pipeline, but this isn&rsquo;t the first pipeline to be initiated in the process. It&rsquo;s easier to create this one first and then clone it later.</p><p>Click <strong>Pipelines</strong> > <strong>Create Pipeline</strong> > <strong>Use the classic editor</strong>. Name it <strong>terraform-plan</strong></p><p>Select <strong>Azure Repos Git</strong> as the source and then ensure it has selected the project, Repo and branch. Click <strong>Continue</strong></p><p><img loading=lazy src=media/newPipeline.png alt=newPipeline></p><p>Click <strong>Start with an Empty Job</strong>. Rename the pipeline and select the &ldquo;Agent Specification&rdquo; as <strong>Ubuntu 20.04</strong></p><p><img loading=lazy src=media/newPipeline1.png alt=newPipeline1></p><p>Select <strong>Agent job 1</strong> and rename it to the same name as the Pipeline. Then click the <strong>+</strong> to add a task. Search <strong>Terraform tool installer</strong>, and click Get it free. Install it, and select your organisation when prompted. Once installed enter the <strong>Version</strong> on the task as <strong>1.2.6</strong> (This was the latest version for linux at the time of writing).</p><p><img loading=lazy src=media/toolInstaller.png alt=toolInstaller></p><p>Add a new <strong>Command Line</strong> task and name it <strong>terraform init</strong>. Set the script as:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>terraform init -backend-config=&#34;access_key=$(Name of access key variable)&#34;
</code></pre><p>This will tell it to check the variable group to match the <code>stgAccountName-key-1</code> variable, which is a Storage Account&rsquo;s access key.</p><p><img loading=lazy src=media/cmd1.png alt=cmd1></p><p>Clone the task and this time rename to <strong>terraform validate</strong>. Set the script the same:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>terraform validate
</code></pre><p>Clone it again and this time rename it to <strong>terraform plan</strong> and set the script as:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>terraform plan -input=false -out=tfplan -var=&#34;spn-client-id=$(CHANGEME-spn-client-id)&#34; -var=&#34;spn-client-secret=$(CHANGEME-spn-secret)&#34; -var=&#34;spn-tenant-id=$(CHANGEME-spn-tenant-id)&#34;
</code></pre><p>This will tell it not to prompt for any input variables at runtime and out to a tfplan file. Ensure the variables are updated with the name of your variables.</p><p>Now create a new task to create an archive of the plan file. The task to add is called <strong>Archive Files</strong> and configure as follows:</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>Disaplay name</td><td>archive terraform plan files</td></tr><tr><td>Root folder or file to archive</td><td>terraform</td></tr><tr><td>Archive type</td><td>tar</td></tr><tr><td>Tar compression</td><td>gz</td></tr><tr><td>Archive file to create</td><td><code>$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-tfplan.tgz</code></td></tr></tbody></table><p><img loading=lazy src=media/tarPlan.png alt=tarPlan></p><p>And finally it is time to publish the pipeline artifacts. Add a task called <strong>Publish Pipline Artifacts</strong> and configure as follows:</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>Display name</td><td>publish terraform plan artifact</td></tr><tr><td>File or directory path</td><td><code>$(Build.ArtifactStagingDirectory)/$(Build.BuildId)-tfplan.tgz</code></td></tr><tr><td>Artifact name</td><td><code>$(Build.BuildId)-tfplan</code></td></tr><tr><td>Artifact publish location</td><td>Azure pipeline</td></tr></tbody></table><p><img loading=lazy src=media/publishArtifacts.png alt=publishArtifacts></p><p>The pipeline tasks should look as follows:</p><p><img loading=lazy src=media/ciTasks.png alt=ciTasks></p><p>That&rsquo;s the last &ldquo;task&rdquo; to add for this pipeline. Now at the top of the pipeline, click <strong>Variables</strong> > <strong>Variable groups</strong> > <strong>Link variable group</strong>. Then select the variable groups which was created earlier.</p><p>Finally, click <strong>Triggers</strong> > tick <strong>enable continuous integration</strong> > Add the path <code>terraform/</code> so that it only takes affect on git changes within the terraform directory (yet to create locally).</p><p><img loading=lazy src=media/trigger1.png alt=trigger1></p><p>Click <strong>save</strong> when complete to save the pipeline.</p><h2 id=create-the-status-check--plan-pull-request-pipline>Create the Status Check & Plan, Pull Request Pipline<a hidden class=anchor aria-hidden=true href=#create-the-status-check--plan-pull-request-pipline>#</a></h2><p>We now need to create a new piplline, not for CI but for to validate the code after Pull Requests are created. Start by cloning the <strong>terraform-plan</strong> pipeline and make the following changes:</p><ul><li>Rename it to <strong>terraform-status-check-plan-and-validate</strong></li><li>Delete the last two tasks <strong>archive terraform plan files</strong> and <strong>publish terraform plan artifact</strong></li><li>Click the <strong>terraform plan</strong> task and delete the <code>-out=tfplan</code> from the Script.</li><li>Click <strong>Triggers</strong> and un-tick (disable) <strong>Enable continuous integration</strong></li><li>Save the pipeline</li></ul><h2 id=release-pipeline>Release Pipeline<a hidden class=anchor aria-hidden=true href=#release-pipeline>#</a></h2><p>The CD/release pipeline is the final one to configure to deploy the resources in Azure using Terraform.</p><p>Go to <strong>Pipelines</strong> > <strong>Releases</strong> > <strong>New pipeline</strong> > name it <strong>terraform apply</strong> > select <strong>Empty job</strong>.</p><p>Name Stage 1 as <strong>terraform apply</strong>. Then click <strong>Add artifact</strong> and select from the <strong>terraform-build</strong> pipeline which was created earlier.</p><p><img loading=lazy src=media/addArtifact.png alt=addArtifact></p><p>Then enable CD by clicking the lightening icon, then <strong>Enabled</strong> under <strong>Continuous deployment trigger</strong>.</p><p><img loading=lazy src=media/enableCD.png alt=enableCD></p><p>Configure the job, under <strong>Stages</strong>, click <strong>1 job, 0 task</strong>. Enter the following:</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>Display name</td><td>terraform apply</td></tr><tr><td>Agent pool</td><td>Azure Pipelines</td></tr><tr><td>Agent Specification</td><td>ubuntu-20.04</td></tr></tbody></table><p>Click the <strong>+</strong> to add a task. Search for and select <strong>Extract files</strong>. Change <strong>Archive file patterns</strong> to:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>$(System.ArtifactsDirectory)/_terraform-plan/$(Build.BuildId)-tfplan/$(Build.BuildId)-tfplan.tgz
</code></pre><p>Set the <strong>Destination folder</strong> to:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>$(System.DefaultWorkingDirectory)/
</code></pre><p>Add a new task called <strong>Terraform tool installer</strong>, set <strong>1.2.6</strong> as the version.</p><p>Add a new task called <strong>Command line</strong>, name it <strong>terraform init</strong> and use the same command line as in the build task.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>terraform init -backend-config=&#34;access_key=$(Name of access key variable)&#34;
</code></pre><p>Then <strong>Advanced</strong> > <strong>Working directory</strong> set it to:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>$(System.DefaultWorkingDirectory)/terraform
</code></pre><p>Clone the Command line task and create a new one called <strong>terraform apply</strong>. Script is:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>terraform apply -auto-approve -input=false tfplan 
</code></pre><p>All tasks will then looks as follows:</p><p><img loading=lazy src=media/applyTasks.png alt=applyTasks></p><p>Now link our variable groups. Click <strong>Variables</strong> > <strong>Variable groups</strong> > <strong>Link varibale group</strong> > Select the variable group created earlier.</p><p>That&rsquo;s all that is required to configure the pipeline tasks, but we need to add a <strong>Pre-deployment condition</strong>, go back to Pipeline and click the following:</p><p><img loading=lazy src=media/deployCondition.png alt=deployCondition></p><p>Enable <strong>Pre-deployment approvals</strong>, I set myself as the approver as I am the only person in my DevOps organisation. I also changed the timeout to <strong>7 Days</strong>.</p><p><img loading=lazy src=media/deployConditions.png alt=deployConditions></p><p>The release pipeline should now look as follows:</p><p><img loading=lazy src=media/releasePipeline.png alt=releasePipeline></p><p>Click <strong>Save</strong></p><h2 id=branch-policies>Branch Policies<a hidden class=anchor aria-hidden=true href=#branch-policies>#</a></h2><p>The Branch policy will ensure that code is only being commited via a pull request and not directly in the main/master branch.</p><p>Click <strong>Repos</strong> > <strong>Branches</strong> > under your default branch, hover over it with mouse and in the far right, click the three dots > <strong>More options</strong> > <strong>Branch Policies</strong>. Set as follows:</p><p><img loading=lazy src=media/branchPolicy1.png alt=branchPolicy1></p><p>Scroll down and enable <strong>Squash merge</strong></p><p><img loading=lazy src=media/branchPolicy2.png alt=branchPolicy2></p><p>Build validation > <strong>+</strong> (add). We only want the <strong>terraform-status-check-plan-and-validate</strong> pipeline to run if there have been any commits on <code>*.tf</code> files. Set as follows:</p><p><img loading=lazy src=media/branchPolicy3.png alt=branchPolicy3></p><p>And finally add myself under <strong>Automatically included reviewers</strong></p><p><img loading=lazy src=media/branchPolicy4.png alt=branchPolicy4></p><p>And that&rsquo;s it for the DevOps configuration. Now it is time to write some Terraform configurations and commit the code to test the pipelines.</p><h2 id=testing-the-build-and-release-pipelines>Testing the Build and Release Pipelines<a hidden class=anchor aria-hidden=true href=#testing-the-build-and-release-pipelines>#</a></h2><p>To create a new branch in VS Code, click <strong>Source Control</strong> > three dots > <strong>Branch</strong> > <strong>Create Branch</strong> > name it <strong>test</strong></p><p>I should not be allowed to commit code changes directly to the <code>master</code> branch now there is a &ldquo;branch policy&rdquo; in place. Start by creating a folder called <code>terraform</code> and add the following <code>.tf.</code> files.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>devops-terraform-build
│
│   .gitignore
│   README.md
│
└───terraform
        backend.tf
        providers.tf
        resource_group.tf
        variables.tf
</code></pre><p>The <code>.gitignore</code> will look something like this:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>#  Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# .tfvars files
*.tfvars
</code></pre><p>The <code>backend.tf</code> file. Ensure you set the correct name for the resource group and storage account which will host the state file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#a6e22e>terraform</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>backend</span> <span style=color:#e6db74>&#34;azurerm&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resource_group_name</span>  = <span style=color:#e6db74>&#34;NAME OF RG&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>storage_account_name</span> = <span style=color:#e6db74>&#34;NAME OF STG&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>container_name</span>       = <span style=color:#e6db74>&#34;devops-tf-state&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span>                  = <span style=color:#e6db74>&#34;terraform.tfstate&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>providers.tf</code> file. Ensure you set your unique subscription id.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#a6e22e>terraform</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>required_providers</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>azurerm</span> = {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>source</span>  = <span style=color:#e6db74>&#34;hashicorp/azurerm&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;=3.0.0&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>provider</span> <span style=color:#e6db74>&#34;azurerm&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>subscription_id</span> = <span style=color:#e6db74>&#34;SUBSCRIPTION ID&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>client_id</span>       = var.<span style=color:#a6e22e>spn</span><span style=color:#f92672>-</span><span style=color:#a6e22e>client</span><span style=color:#f92672>-</span><span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>client_secret</span>   = var.<span style=color:#a6e22e>spn</span><span style=color:#f92672>-</span><span style=color:#a6e22e>client</span><span style=color:#f92672>-</span><span style=color:#a6e22e>secret</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tenant_id</span>       = var.<span style=color:#a6e22e>spn</span><span style=color:#f92672>-</span><span style=color:#a6e22e>tenant</span><span style=color:#f92672>-</span><span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>features</span> {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>resource_group.tf</code> file. Set the name of the resource group you want to create. This is all that will be created for now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;azurerm_resource_group&#34;</span> <span style=color:#e6db74>&#34;rg1&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span>     = <span style=color:#e6db74>&#34;devops-terraform-rg1&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>location</span> = <span style=color:#e6db74>&#34;UK South&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>variables.tf</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-terraform data-lang=terraform><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;spn-client-id&#34;</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;spn-client-secret&#34;</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;spn-tenant-id&#34;</span> {}
</span></span></code></pre></div><h2 id=deploy-resources>Deploy Resources<a hidden class=anchor aria-hidden=true href=#deploy-resources>#</a></h2><p>Now we can deploy the resource group. In VS Code, click Source Control > then the <strong>+</strong> (stage) > Tick to commit > Name the commit > and then <strong>Push</strong></p><p>Back in Azure DevOps, in <strong>Repos</strong> you&rsquo;ll see the <code>test</code> branch has been commited and that you have an option to <strong>Create a pull request</strong>. Click it.</p><p><img loading=lazy src=media/createPullRequest.png alt=createPullRequest></p><p>Fill in name and description and click <strong>Create</strong></p><p>Notice the pipeline which performs a terraform plan and validate has passed</p><p><img loading=lazy src=media/checkPassed.png alt=checkPassed></p><p>Click it to see the jobs.</p><p><img loading=lazy src=media/checkPassed1.png alt=checkPassed1></p><p>Select the <strong>terraform plan</strong> job to see detailed output. Notice one resource will be created; the resource group.</p><p><img loading=lazy src=media/ciPlan.png alt=ciPlan></p><p>If I open Azure and browse to the Storage Account and Container, I can see the state file created by the <code>terraform init</code> command.</p><p><img loading=lazy src=media/tfState.png alt=tfState></p><p>Now approve the Pull request to merge the test branch into Master</p><p><img loading=lazy src=media/completePR.png alt=completePR></p><p>This will initiate the build pipeline to create a plan file as an artifact.</p><p><img loading=lazy src=media/planJobs.png alt=planJobs></p><p>Select <strong>archive terraform plan files</strong> for detailed output of the command.</p><p><img loading=lazy src=media/archivePlan.png alt=archivePlan></p><p>Now approve the release by going to <strong>Pipelines</strong> > <strong>Releases</strong></p><p><img loading=lazy src=media/approveRelease.png alt=approveRelease></p><p>Then watch the release pipepline progress and deploy the Resource Group to Azure.</p><p><img loading=lazy src=media/applyComplete.png alt=applyComplete></p><p>Once complete you can see the new Resource Group &ldquo;devops-terraform-rg1&rdquo; was created.</p><p><img loading=lazy src=media/rg.png alt=rg></p><p>That&rsquo;s a lot of work to deploy a resource group. But now I can create new branches with more resources and have Azure DevOps deploy then when the branch is merged. But first I will show you how to cleanup up the old branch in VS Code.</p><h2 id=clean-up-local-repo>Clean up local repo<a hidden class=anchor aria-hidden=true href=#clean-up-local-repo>#</a></h2><p>Now the &ldquo;test&rdquo; branch has been merged into main/master (in my example; master), we can cleanup the local test branch and swtich back to master.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>git checkout master
</code></pre><p>You&rsquo;ll notice in VS Code in the bottom left that the branch has changed.</p><p>Fetch and prune. The -p option tells fetch to delete any references that no longer exist on the remote origin. Git remote prune will also remove deleted branches.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>git fetch -p
</code></pre><p>Then &ldquo;pull&rdquo; the updates on the origin repo to your local repo.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>git pull
</code></pre><p>Delete the old, local &ldquo;test&rdquo; branch</p><pre tabindex=0><code class=language-terminal data-lang=terminal>git branch -D test
</code></pre><p>Verify your local branches</p><pre tabindex=0><code class=language-terminal data-lang=terminal>git branch -a
</code></pre><p>That&rsquo;s it. Create a new branch if you want to commit new code as a pull request.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://markkerry.github.io/tags/terraform/>Terraform</a></li><li><a href=https://markkerry.github.io/tags/azure-devops/>Azure DevOps</a></li><li><a href=https://markkerry.github.io/tags/azure/>Azure</a></li><li><a href=https://markkerry.github.io/tags/git/>Git</a></li></ul><nav class=paginav><a class=next href=https://markkerry.github.io/posts/2022/07/azure-func-university-python-lesson/><span class=title>Next Page »</span><br><span>Azure Functions University Python Lesson</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://markkerry.github.io/>markkerry.github.io</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>